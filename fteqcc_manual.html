<html>
<head>
	<title>FTEQCC Manual</title>
</head>
<body>
	<h1>FTEQCC DOCUMENTATION</h1>
	<p>Contents by David Walton and Marco Hladik.
Edited and compiled by Marco Hladik.

Last updated: 10th August 2018, 9:21 PM GMT</p>

<h2>Index</h2>

<ol>
  <li>Overview
    <ol>
      <li>Server-Side QuakeC (SSQC)</li>
      <li>Client-Side QuakeC (CSQC)</li>
      <li>Menu QuakeC (MenuQC)</li>
    </ol>
  </li>
  <li>Getting Started</li>
  <li>Command-Line</li>
  <li>Project Management</li>
  <li>Other Pre-Processor</li>
  <li>Control Statements</li>
  <li>Basic Types
    <ol>
      <li>entity</li>
      <li>float</li>
      <li>string</li>
      <li>int</li>
      <li>vector</li>
      <li>__variant</li>
    </ol>
  </li>
  <li>Complex Types
    <ol>
      <li>arrays</li>
      <li>fields</li>
      <li>functions</li>
      <li>typedef</li>
      <li>enum / enumflags / strongly typed enums</li>
      <li>struct</li>
      <li>union</li>
      <li>class</li>
      <li>pointer</li>
      <li>Accessors</li>
    </ol>
  </li>
  <li>Type Modifiers
    <ol>
      <li>const / var</li>
      <li>__unused / noref</li>
      <li>__used</li>
      <li>local</li>
      <li>static / nonstatic</li>
      <li>nosave</li>
      <li>inline</li>
      <li>strip / __ignore</li>
      <li>shared</li>
      <li>optional</li>
      <li>__inout / __in / __out</li>
      <li>__weak</li>
      <li>__wrap</li>
      <li>__accumulate</li>
    </ol>
  </li>
  <li>Operators</li>
  <li>Intrinsics</li>
  <li>Modelgen Commands</li>
  <li>Compiler Flags</li>
  <li>Engine Support</li>
</ol>

<h3>Overview</h3>
<p>QuakeC is a language originally created by ID software for use in in the
video game Quake. Vanilla QuakeC is quite a limited language, however with qcc
improvements and engine extensions, its less annoying to write and also much
more capable as a programming language.

Today we're dealing with different types of modules. The original QuakeC only
supported the modification of game-code run on the server. It was not capable
of altering any client-side behaviour. Just send a selection of commands and
hope that the client interprets the stuff properly.</p>
<h4>Server-Side QuakeC (SSQC)</h4>
<p>This is the classic form of QuakeC, and is the module executed by the server
component. SSQC's reason to exist is so that it can deal with networking. 
It is normally considered authoritive, which is a fancy way of saying that CSQC
isn't to be trusted (if only due to packetloss). 
As such, the SSQC is normally expected to track the state of any entity that has
any impact on the outcome of a game.

In mods designed to run without CSQC, the SSQC generally does a lot more than
just that, however it is also potentially running on a computer on the other
side of the planet, so while you can write your entire game in just the SSQC
module, doing so means that you have no control over the user's actual screen,
and anything that is displayed can be quite laggy which may limit what you can
expect to achieve with SSQC alone.

There are two major variations of SSQC:</p>
<ol>
  <li>NetQuake (NQ):
The original and more common type.</li>
<li>QuakeWorld (QW):
Which was originally meant for deathmatch only. 
It streamlines some things but in the process has a number of omissions that
break singleplayer quake (most qw mods lack any singleplayer/coop logic, with
no support for any monsters).

Thus most engines focus on NQ, even FTEQW!
SSQC tends to be very object orientated. There are comparatively few
non-constant globals as multiple pontential players/etc hinder the use of such
individual globals.</li>
</ol>

<h4>Client-Side QuakeC (CSQC)</h4>
<p>This module runs clientside. Each client potentially has its own instance of
CSQC, and thus they'll all end up disagreeing about some part of the game
without the SSQC to provide authoritive information - remember this: 
The SSQC knows best.

CSQC normally has full control over the client's screen (via builtins). It is
normally the CSQC that decides when and where to draw the various hud elements.
The CSQC also has control over the 3d view, and can not only decide where to
draw the 3d view, but it can also change the camera as well as directly control
the entities that are inserted into that view.
However, not every engine supports CSQC, and those that do might have it
disabled for whatever reason.

There are three variations of CSQC:</p>
<ol>
  <li>FTE:
This was the first version of CSQC (if you ignore that CSQC was predated by
menuqc). It is also the one that supports the most extensions since.</li>
  <li>DP:
DP's CSQC implementation was an attempt to follow a poorly understood and
incomplete description of FTE's CSQC implementation. As a result, it does
many things in a sub-par way and refuses to improve upon any of it because
doing so might break one of the mods that use it.
Even so, you can still achieve some awesome stuff with it, it just tends to
be more limited than in FTE.</li>
  <li>Simple CSQC:
This variation of CSQC is a cut down version of CSQC. It is restricted from
various actions and is unable to query anything about the game beyond the
stats. Its sole purpose is to allow it to draw 2d elements including hud,
scoreboard, and menus. The crc of the csprogs.dat explcitly matches that
of the nq progs.dat, which allows client+server to reuse various builtins
etc, simplifying the implementation further, this also permits the entry
points to be provided by the progs.dat itself although this is more of a
convienience than anything else (it should still run in a seperate VM and
thus have no access to ssqc state).
As an improper subset, it is trivial to create a DP-compatible csprogs that
wraps the Simple CSQC entrypoints, allowing one csprogs to run seamlessly in
FTE+QSS+DP, and hopefully also other engines in the future.</li>
</ol>
<p>CSQC tends to be more procedural than SSQC.
Generally there is only one player so that info can all be stored in globals
instead of entities (splitscreen may require arrays).</p>



</body>
</html>